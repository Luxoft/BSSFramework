using System.Reflection;

using CommonFramework;

namespace Framework.Core;

public static class CorePropertyInfoExtensions
{
    public static bool HasGetMethod(this PropertyInfo propertyInfo, bool nonPublic = false)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        return propertyInfo.GetGetMethod(nonPublic) != null;
    }

    public static bool HasFamilyGetMethod(this PropertyInfo propertyInfo)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        return propertyInfo.HasGetMethod()
               || propertyInfo.GetGetMethod(true).Maybe(method => method.Attributes.HasFlag(MethodAttributes.Family));
    }

    public static bool HasFamilySetMethod(this PropertyInfo propertyInfo)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        return propertyInfo.HasSetMethod()
               || propertyInfo.GetSetMethod(true).Maybe(method => method.Attributes.HasFlag(MethodAttributes.Family));
    }

    public static bool IsAssignableFrom(this PropertyInfo property, PropertyInfo nestedProp, bool byGet = true)
    {
        if (property == null) throw new ArgumentNullException(nameof(property));

        return nestedProp.GetBaseProperties(byGet).Contains(property);
    }

    public static bool HasSetMethod(this PropertyInfo propertyInfo, bool nonPublic = false)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        return propertyInfo.GetSetMethod(nonPublic) != null;
    }

    public static bool IsHierarchical(this PropertyInfo propertyInfo)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        return propertyInfo.PropertyType.GetCollectionElementType() == propertyInfo.DeclaringType;
    }

    /// <summary>
    /// Получение приватного филда по свойству
    /// </summary>
    /// <param name="propertyInfo">Свойство</param>
    /// <param name="preFieldName">Кастомное имя филда</param>
    /// <returns></returns>
    public static FieldInfo? GetPrivateField(this PropertyInfo propertyInfo, string? preFieldName = null)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        return propertyInfo.GetPrivateFieldInternal(propertyInfo.DeclaringType!, preFieldName);
    }

    public static PropertyInfo? GetBaseProperty(this PropertyInfo property, bool byGet = true)
    {
        if (property == null) throw new ArgumentNullException(nameof(property));

        var currentMethod = byGet ? (property.GetGetMethod() ?? property.GetGetMethod(true))
                                : (property.GetSetMethod() ?? property.GetSetMethod(true));

        var baseMethod = currentMethod.Maybe(v => v.GetBaseDefinition());

        return baseMethod.Maybe(v => v.ReflectedType == property.ReflectedType
                                         ? null
                                         : v.ReflectedType!.GetProperty(property.Name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance));
    }

    public static IEnumerable<PropertyInfo> GetBaseProperties(this PropertyInfo property, bool byGet = true)
    {
        if (property == null) throw new ArgumentNullException(nameof(property));

        return property.GetAllElements(p => p.GetBaseProperty(byGet));
    }


    public static PropertyInfo GetTopProperty(this PropertyInfo property, bool byGet = true)
    {
        if (property == null) throw new ArgumentNullException(nameof(property));

        return property.GetBaseProperties().Last();
    }

    public static bool HasPrivateField(this PropertyInfo propertyInfo, string? preFieldName = null)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        return propertyInfo.HasPrivateFieldInternal(preFieldName);
    }

    public static bool HasPrivateField(this PropertyInfo propertyInfo, bool withAutoGenerated)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        return propertyInfo.HasPrivateFieldInternal()
               || (withAutoGenerated && propertyInfo.HasPrivateField($"<{propertyInfo.Name}>k__BackingField"));
    }

    private static bool HasPrivateFieldInternal(this PropertyInfo propertyInfo, string? preFieldName = null)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        return propertyInfo.HasPrivateField(propertyInfo.DeclaringType!, preFieldName);
    }

    public static bool HasPrivateField(this PropertyInfo propertyInfo, Type declaringType, string? preFieldName = null)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        return propertyInfo.HasPrivateFieldInternal(declaringType, preFieldName)

            // || (preFieldName == null && propertyInfo.HasPrivateFieldInternal("_" + propertyInfo.Name.ToStartLowerCase()))
            ;
    }

    private static bool HasPrivateFieldInternal(this PropertyInfo propertyInfo, Type declaringType, string? preFieldName = null)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        return propertyInfo.GetPrivateFieldInternal(declaringType, preFieldName) != null;
    }

    private static FieldInfo? GetPrivateFieldInternal(this PropertyInfo propertyInfo, Type declaringType, string? preFieldName = null)
    {
        if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));

        var fieldName = preFieldName ?? propertyInfo.Name.ToStartLowerCase();

        var request = from type in declaringType.GetAllElements(t => t.BaseType)

                      let field = type.GetField(fieldName, BindingFlags.NonPublic | BindingFlags.Instance)

                      where field != null && field.DeclaringType == type && propertyInfo.PropertyType.IsAssignableFrom(field.FieldType)

                      select field;

        return request.SingleOrDefault();
    }
}
